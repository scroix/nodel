import org.apache.tools.ant.filters.ReplaceTokens
import org.joda.time.DateTime

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath 'joda-time:joda-time:2.10.10'
    }
}

plugins {
    id 'java'
    id 'eclipse'
    id 'maven-publish'
    id 'com.github.node-gradle.node' version '7.0.2'
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'joda-time:joda-time:2.10.10'
    implementation 'org.joda:joda-convert:2.2.1'
}

static def getGitInfo() {
    return [
            branch : 'git rev-parse --abbrev-ref HEAD'.execute().text.trim(),
            id     : 'git rev-parse HEAD'.execute().text.trim(),
            rev    : 'git rev-list --count HEAD'.execute().text.trim(),
            origin : 'git config --get remote.origin.url'.execute().text.trim()
    ]
}

def buildSummary = gitInfo.id
def hostname = InetAddress.getLocalHost().getHostName().toUpperCase()
def now = DateTime.now().toString()
def rev = gitInfo.rev.replaceAll(/[^a-zA-Z0-9]/, '')
def branch = gitInfo.branch

version = gitInfo.branch != 'stable' ? "${project.version}-${branch}_r${rev}" : project.version

node {
    version = '16.20.2'
    download = true
    workDir = file("${project.buildDir}/nodejs")

    npmInstallCommand = System.getenv("CI") ? 'ci' : 'install'
}

tasks.register('checkNodeModules') {
    def nodeModulesDir = file("${projectDir}/node_modules")
    outputs.upToDateWhen { nodeModulesDir.exists() }
}

def srcDir = file('src')
def packageJson = file('package.json')
def packageLockJson = file('package-lock.json')
def gruntFile = file('Gruntfile.js')

def filesChanged = false

static def checkFilesChanged(Project project) {
    def nodeModulesDir = project.file("${project.projectDir}/node_modules")
    def srcDir = project.file('src')
    def packageJson = project.file('package.json')
    def packageLockJson = project.file('package-lock.json')
    def gruntFile = project.file('Gruntfile.js')

    if (!nodeModulesDir.exists()) {
        // println "node_modules directory does not exist. Setting filesChanged to true."
        return true
    } else {
        def srcDirModified = srcDir.exists() && srcDir.lastModified() > nodeModulesDir.lastModified()
        def packageJsonModified = packageJson.exists() && packageJson.lastModified() > nodeModulesDir.lastModified()
        def packageLockJsonModified = packageLockJson.exists() && packageLockJson.lastModified() > nodeModulesDir.lastModified()
        def gruntFileModified = gruntFile.exists() && gruntFile.lastModified() > nodeModulesDir.lastModified()

        def filesChanged = srcDirModified || packageJsonModified || packageLockJsonModified || gruntFileModified

        // println "srcDirModified: ${srcDirModified}"
        // println "packageJsonModified: ${packageJsonModified}"
        // println "packageLockJsonModified: ${packageLockJsonModified}"
        // println "gruntFileModified: ${gruntFileModified}"
        // println "filesChanged: ${filesChanged}"

        return filesChanged
    }
}

tasks.named('clean', Delete) {
    delete "${projectDir}/node_modules/"
    delete "${projectDir}/build/grunt/"
}

tasks.register('installGruntCli', NpmTask) {
    def shouldInstall = checkFilesChanged(project)

    if (shouldInstall) {
        dependsOn clean
    }

    args = ['install', 'grunt-cli', '--save-dev', '--legacy-peer-deps']

    inputs.property('filesChanged', shouldInstall)
    outputs.dir('node_modules')

    onlyIf { shouldInstall }
}

tasks.register('gruntRun', NpxTask) {
    def shouldInstall = checkFilesChanged(project)


    dependsOn 'installGruntCli'
    command = "grunt"
    args = ["build"]
    inputs.property('filesChanged', shouldInstall)
    inputs.dir("node_modules")
    outputs.dir("build/grunt")

    onlyIf { shouldInstall }
}

tasks.register('checkDistDirectory', Task) {
    dependsOn gruntRun
    doLast {
        def distDir = file("${project.buildDir}/dist")
        if (distDir.exists()) {
            println "Contents of 'dist' directory:"
            distDir.eachFile { file ->
                println file.name
            }
        } else {
            println "'dist' directory does not exist"
        }
    }
}

tasks.register('copyContent', Copy) {
    dependsOn gruntRun, checkDistDirectory
    from file("${project.buildDir}/grunt")
    into file("${project.buildDir}/www-content_stage")
    exclude 'build.json'
}

tasks.register('filterContentTemplates', Copy) {
    from 'src'
    into file("${project.buildDir}/www-content_stage")
    include 'build.json'
    filter(ReplaceTokens, tokens: [
            buildSummary: (project.name + "-" + project.version + " " + buildSummary + " (" + hostname + ") " + now).toString(),
            buildOrigin : gitInfo.origin.toString(),
            buildProject: project.name.toString(),
            buildBranch : branch.toString(),
            buildVersion: project.version.toString(),
            buildId     : buildSummary.toString(),
            buildRev    : rev.toString(),
            buildHost   : hostname.toString(),
            buildDate   : now.toString()
    ])
}

tasks.register('zipContentInterface', Zip) {
    dependsOn copyContent, filterContentTemplates
    from file("${project.buildDir}/www-content_stage")
    archiveName 'content.zip'
    destinationDirectory = file("${project.buildDir}/www-content/org/nodel/host")
}

tasks.register('copyBuildInfo', Copy) {
    dependsOn copyContent, filterContentTemplates
    from file("${project.buildDir}/www-content_stage")
    include 'build.json'
    into file("${project.buildDir}/www-content/org/nodel")
}

sourceSets {
    main {
        resources.srcDirs = [file("${project.buildDir}/www-content")]
    }
}

tasks.named('compileJava') {
    dependsOn zipContentInterface, copyBuildInfo
}

tasks.named('processResources') {
    dependsOn zipContentInterface, copyBuildInfo
}

dependencies {
    implementation 'joda-time:joda-time:2.10.10'
    implementation 'org.joda:joda-convert:2.2.1'
}